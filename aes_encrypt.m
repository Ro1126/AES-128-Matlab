% Definirea cheii și plaintext-ului direct
key_hex = '000102030405060708090a0b0c0d0e0f';
plaintext_hex = '00112233445566778899aabbccddeeff';

% Convertim șirurile hexazecimale în vectori de octeți (uint8)
key = uint8(hex2dec(reshape(key_hex, 2, [])')');
plaintext = uint8(hex2dec(reshape(plaintext_hex, 2, [])')');

disp('Input plaintext (hex):');
disp(plaintext_hex);
disp('Key (hex):');
disp(key_hex);



% Adaugare padding (nu e necesar aici)
if mod(length(plaintext), 16) ~= 0
    a = 16 - mod(length(plaintext), 16);
    plaintext = [plaintext; uint8(zeros(a, 1) + a)];
end

% Inițializarea stării cheii
key_state = reshape(key(1:16), 4, 4);
disp('Initial key state (hex):');
fprintf('%02x', key_state(:)');

% Transformarea textului clar în stări 4x4
plaintext_states = PlaintextStates(plaintext);
nr_blocks = size(plaintext_states, 3);

% Procesarea AES pe fiecare bloc
for i = 1:nr_blocks
    % Starea inițială
    state = plaintext_states(:,:,i);
    disp('Start of encryption (hex):');
    fprintf('%02x', state(:)');

    % Runda inițială AddRoundKey
    state = AddRoundKey(state, key_state);
    disp(' After initial AddRoundKey (hex):');
    fprintf('%02x', state(:)');

    % 10 runde (9 principale + 1 finală)
    for runda = 1:10
        disp(['Round ', num2str(runda), ':']);
        % SubBytes
        disp('Before SubBytes (hex):');
fprintf('%02x ', state(:)');
        state = Subbyte(state);
        disp('  After SubBytes (hex):');
        fprintf('%02x', state(:)');

        % ShiftRows
        state = ShiftRows(state);
        disp(' After ShiftRows (hex):');
        fprintf('%02x', state(:)');

        % MixColumns (nu se aplică în runda 10)
        if runda ~= 10
            state = MixColumns(state);
            disp(' After MixColumns (hex):');
            fprintf('%02x', state(:)');
        end
            % Extinderea cheii
            key_state = roundkey(key_state, runda);
            disp('Round key (hex):');
            fprintf('%02x', key_state(:)');

            % AddRoundKey
            state = AddRoundKey(state, key_state);
            disp('After AddRoundKey (hex):');
            fprintf('%02x', state(:)');
        end

    % Salvează starea procesată
    plaintext_states(:,:,i) = state;
end

% Reshape rezultatul final într-un vector
ciphertext = reshape(plaintext_states, [], 1);
ciphertext_hex = sprintf('%02x', ciphertext);
disp('Final Ciphertext (hex):');
disp(ciphertext_hex);
fid=fopen("output.txt",'w');
fprintf(fid,'%02x',ciphertext);

% Funcții auxiliare

function [plaintext_states] = PlaintextStates(plaintext)
    lungime = length(plaintext) / 16;
    plaintext_states = reshape(plaintext, 4, 4, lungime);
end

function [plaintext] = Subbyte(plaintext)
    S_box = uint8([
        0x63 0x7c 0x77 0x7b 0xf2 0x6b 0x6f 0xc5 0x30 0x01 0x67 0x2b 0xfe 0xd7 0xab 0x76;
        0xca 0x82 0xc9 0x7d 0xfa 0x59 0x47 0xf0 0xad 0xd4 0xa2 0xaf 0x9c 0xa4 0x72 0xc0;
        0xb7 0xfd 0x93 0x26 0x36 0x3f 0xf7 0xcc 0x34 0xa5 0xe5 0xf1 0x71 0xd8 0x31 0x15;
        0x04 0xc7 0x23 0xc3 0x18 0x96 0x05 0x9a 0x07 0x12 0x80 0xe2 0xeb 0x27 0xb2 0x75;
        0x09 0x83 0x2c 0x1a 0x1b 0x6e 0x5a 0xa0 0x52 0x3b 0xd6 0xb3 0x29 0xe3 0x2f 0x84;
        0x53 0xd1 0x00 0xed 0x20 0xfc 0xb1 0x5b 0x6a 0xcb 0xbe 0x39 0x4a 0x4c 0x58 0xcf;
        0xd0 0xef 0xaa 0xfb 0x43 0x4d 0x33 0x85 0x45 0xf9 0x02 0x7f 0x50 0x3c 0x9f 0xa8;
        0x51 0xa3 0x40 0x8f 0x92 0x9d 0x38 0xf5 0xbc 0xb6 0xda 0x21 0x10 0xff 0xf3 0xd2;
        0xcd 0x0c 0x13 0xec 0x5f 0x97 0x44 0x17 0xc4 0xa7 0x7e 0x3d 0x64 0x5d 0x19 0x73;
        0x60 0x81 0x4f 0xdc 0x22 0x2a 0x90 0x88 0x46 0xee 0xb8 0x14 0xde 0x5e 0x0b 0xdb;
        0xe0 0x32 0x3a 0x0a 0x49 0x06 0x24 0x5c 0xc2 0xd3 0xac 0x62 0x91 0x95 0xe4 0x79;
        0xe7 0xc8 0x37 0x6d 0x8d 0xd5 0x4e 0xa9 0x6c 0x56 0xf4 0xea 0x65 0x7a 0xae 0x08;
        0xba 0x78 0x25 0x2e 0x1c 0xa6 0xb4 0xc6 0xe8 0xdd 0x74 0x1f 0x4b 0xbd 0x8b 0x8a;
        0x70 0x3e 0xb5 0x66 0x48 0x03 0xf6 0x0e 0x61 0x35 0x57 0xb9 0x86 0xc1 0x1d 0x9e;
        0xe1 0xf8 0x98 0x11 0x69 0xd9 0x8e 0x94 0x9b 0x1e 0x87 0xe9 0xce 0x55 0x28 0xdf;
        0x8c 0xa1 0x89 0x0d 0xbf 0xe6 0x42 0x68 0x41 0x99 0x2d 0x0f 0xb0 0x54 0xbb 0x16
    ]);
    [rows, cols] = size(plaintext);
    for i = 1:rows
        for j = 1:cols
            val = plaintext(i,j);
            row = floor(double(val)/16) + 1;
            col = mod(val, 16) + 1;
            plaintext(i,j) = S_box(row, col);
        end
    end
end

function [text] = ShiftRows(mat)
    mat(2,:) = circshift(mat(2,:), -1);
    mat(3,:) = circshift(mat(3,:), -2);
    mat(4,:) = circshift(mat(4,:), -3);
    text = mat;
end

function [output_text] = AddRoundKey(text, cheie)
    output_text = bitxor(text, cheie);
end

function [row] = RotWord(row)
    row = circshift(row, -1);
end

function [word] = Subword(word)
    S_box = uint8([
        0x63 0x7c 0x77 0x7b 0xf2 0x6b 0x6f 0xc5 0x30 0x01 0x67 0x2b 0xfe 0xd7 0xab 0x76;
        0xca 0x82 0xc9 0x7d 0xfa 0x59 0x47 0xf0 0xad 0xd4 0xa2 0xaf 0x9c 0xa4 0x72 0xc0;
        0xb7 0xfd 0x93 0x26 0x36 0x3f 0xf7 0xcc 0x34 0xa5 0xe5 0xf1 0x71 0xd8 0x31 0x15;
        0x04 0xc7 0x23 0xc3 0x18 0x96 0x05 0x9a 0x07 0x12 0x80 0xe2 0xeb 0x27 0xb2 0x75;
        0x09 0x83 0x2c 0x1a 0x1b 0x6e 0x5a 0xa0 0x52 0x3b 0xd6 0xb3 0x29 0xe3 0x2f 0x84;
        0x53 0xd1 0x00 0xed 0x20 0xfc 0xb1 0x5b 0x6a 0xcb 0xbe 0x39 0x4a 0x4c 0x58 0xcf;
        0xd0 0xef 0xaa 0xfb 0x43 0x4d 0x33 0x85 0x45 0xf9 0x02 0x7f 0x50 0x3c 0x9f 0xa8;
        0x51 0xa3 0x40 0x8f 0x92 0x9d 0x38 0xf5 0xbc 0xb6 0xda 0x21 0x10 0xff 0xf3 0xd2;
        0xcd 0x0c 0x13 0xec 0x5f 0x97 0x44 0x17 0xc4 0xa7 0x7e 0x3d 0x64 0x5d 0x19 0x73;
        0x60 0x81 0x4f 0xdc 0x22 0x2a 0x90 0x88 0x46 0xee 0xb8 0x14 0xde 0x5e 0x0b 0xdb;
        0xe0 0x32 0x3a 0x0a 0x49 0x06 0x24 0x5c 0xc2 0xd3 0xac 0x62 0x91 0x95 0xe4 0x79;
        0xe7 0xc8 0x37 0x6d 0x8d 0xd5 0x4e 0xa9 0x6c 0x56 0xf4 0xea 0x65 0x7a 0xae 0x08;
        0xba 0x78 0x25 0x2e 0x1c 0xa6 0xb4 0xc6 0xe8 0xdd 0x74 0x1f 0x4b 0xbd 0x8b 0x8a;
        0x70 0x3e 0xb5 0x66 0x48 0x03 0xf6 0x0e 0x61 0x35 0x57 0xb9 0x86 0xc1 0x1d 0x9e;
        0xe1 0xf8 0x98 0x11 0x69 0xd9 0x8e 0x94 0x9b 0x1e 0x87 0xe9 0xce 0x55 0x28 0xdf;
        0x8c 0xa1 0x89 0x0d 0xbf 0xe6 0x42 0x68 0x41 0x99 0x2d 0x0f 0xb0 0x54 0xbb 0x16
    ]);
    for i = 1:length(word)
        val = word(i);
        row = floor(double(val)/16) + 1;
        col = mod(val, 16) + 1;
        word(i) = S_box(row, col);
    end
end
function [state1] = MixColumns(state)
    j=1;
    for i=1:4:16
        state1(i)=bitxor(bitxor(bitxor(auxiliar(state(1,j),2),auxiliar(state(2,j),3)),state(3,j)),state(4,j));
        state1(i+1)=bitxor(bitxor(bitxor(state(1,j),auxiliar(state(2,j),2)),auxiliar(state(3,j),3)),state(4,j));
        state1(i+2)=bitxor(bitxor(bitxor(state(1,j),state(2,j)),auxiliar(state(3,j),2)),auxiliar(state(4,j),3));
        state1(i+3)=bitxor(bitxor(bitxor(auxiliar(state(1,j),3),state(2,j)),state(3,j)),auxiliar(state(4,j),2));
        j=j+1;
    end
    state1=reshape(state1,4,4);
end

function [state1]=auxiliar(state,number)
    state=uint16(state);
    if state*number>255
        if number==2
           state1=bitxor(state*number,283);
        elseif number==3
            if state*2>255
            state1=bitxor(2*state,283);
            else
                state1=2*state;
            end
            state1=bitxor(state1,state);
        end
    elseif number==2
            state1=state*number;
    else
        state1=bitxor(state*2,state);
    end
    state1=uint8(state1);
end

function [key_state] = roundkey(key_state, runda)
    % Definirea Rcon
Rcon = uint8([
    0x01 0x00 0x00 0x00;
    0x02 0x00 0x00 0x00;
    0x04 0x00 0x00 0x00;
    0x08 0x00 0x00 0x00;
    0x10 0x00 0x00 0x00;
    0x20 0x00 0x00 0x00;
    0x40 0x00 0x00 0x00;
    0x80 0x00 0x00 0x00;
    0x1B 0x00 0x00 0x00;
    0x36 0x00 0x00 0x00
]);
    if runda > size(Rcon, 1)
        error('Runda %d depășește dimensiunea Rcon (%d rânduri)', runda, size(Rcon, 1));
    end
    temp = RotWord(key_state(:,4));
    temp = Subword(temp);
    key_state(:,1) = bitxor(key_state(:,1), temp);
    key_state(:,1) = bitxor(key_state(:,1), Rcon(runda,:)');
    key_state(:,2) = bitxor(key_state(:,2), key_state(:,1));
    key_state(:,3) = bitxor(key_state(:,3), key_state(:,2));
    key_state(:,4) = bitxor(key_state(:,4), key_state(:,3));
end

%function [text_prelucrat] = RoundTextState(text, runda)
 %   text_prelucrat = Subbyte(text);
  %  text_prelucrat = ShiftRows(text_prelucrat);
   % if runda ~= 10
    %    text_prelucrat = MixColumns(text_prelucrat);
    %end
%end